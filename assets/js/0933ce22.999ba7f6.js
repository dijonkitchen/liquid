"use strict";(self.webpackChunkliquid_docs=self.webpackChunkliquid_docs||[]).push([[9086],{2897:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>p,toc:()=>o});var a=n(3117),i=(n(7294),n(3905));const r={},l="Extra Tags",p={unversionedId:"extra/tags",id:"extra/tags",title:"Extra Tags",description:"_New in version 1.5.0_",source:"@site/docs/extra/tags.md",sourceDirName:"extra",slug:"/extra/tags",permalink:"/liquid/extra/tags",draft:!1,editUrl:"https://github.com/jg-rp/liquid/tree/docs/docs/extra/tags.md",tags:[],version:"current",frontMatter:{},sidebar:"languageSidebar",previous:{title:"Extra Filters",permalink:"/liquid/extra/filters"},next:{title:"Python Liquid Babel",permalink:"/liquid/babel/introduction"}},s={},o=[{value:"if (not)",id:"if-not",level:2},{value:"Parentheses",id:"parentheses",level:3},{value:"inline if / else",id:"inline-if--else",level:2},{value:"With Filters",id:"with-filters",level:3},{value:"macro / call",id:"macro--call",level:2},{value:"Excess Arguments",id:"excess-arguments",level:3},{value:"with",id:"with",level:2}],d={toc:o};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"extra-tags"},"Extra Tags"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"New in version 1.5.0"))),(0,i.kt)("p",null,"This page documents extra tags that are not included in standard Liquid. See the ",(0,i.kt)("a",{parentName:"p",href:"/liquid/language/tags"},"tag reference")," for a details of all standard tags. Each tag described here must be registered with a ",(0,i.kt)("a",{parentName:"p",href:"/liquid/api/Environment"},(0,i.kt)("inlineCode",{parentName:"a"},"liquid.Environment"))," to make it available to templates rendered from that environment."),(0,i.kt)("h2",{id:"if-not"},"if (not)"),(0,i.kt)("p",null,"A drop-in replacement for the standard ",(0,i.kt)("a",{parentName:"p",href:"/liquid/language/tags#if"},(0,i.kt)("inlineCode",{parentName:"a"},"if"))," tag that supports a logical ",(0,i.kt)("inlineCode",{parentName:"p"},"not")," operator and grouping terms with parentheses. See ",(0,i.kt)("a",{parentName:"p",href:"/liquid/language/tags#expressions"},"the tag reference")," for a description of standard ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," expressions."),(0,i.kt)("p",null,"In this example, ",(0,i.kt)("inlineCode",{parentName:"p"},"{% if not user %}")," is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"{% unless user %}"),", however, ",(0,i.kt)("inlineCode",{parentName:"p"},"not")," can also be used after ",(0,i.kt)("inlineCode",{parentName:"p"},"and")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"or"),", like ",(0,i.kt)("inlineCode",{parentName:"p"},"{% if user.active and not user.title %}"),", potentially saving nested ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"unless")," tags."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from liquid import Environment\nfrom liquid.extra.tags import IfNotTag\n\nenv = Environment()\nenv.add_tag(IfNotTag)\n\ntemplate = env.from_string("""\\\n{% if not user %}\n  please log in\n{% else %}\n  hello user\n{% endif %}\n""")\n\ndata = {\n  "user": {\n    "eligible": False,\n    "score": 5\n  }\n}\n\nprint(template.render(**data))\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain",metastring:'title="output"',title:'"output"'},"hello user\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"not")," prefix operator uses Liquid truthiness. Only ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"nil")," are not truthy. Empty strings, arrays and objects all evaluate to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,i.kt)("h3",{id:"parentheses"},"Parentheses"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"and")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"or")," operators in Liquid are right associative. Where ",(0,i.kt)("inlineCode",{parentName:"p"},"true and false and false or true")," is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"(true and (false and (false or true)))"),", evaluating to ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),". Python, on the other hand, would parse the same expression as ",(0,i.kt)("inlineCode",{parentName:"p"},"(((true and false) and false) or true)"),", evaluating to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,i.kt)("p",null,"This implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," maintains that right associativity so that any standard ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," expression will behave the same, with or without non-standard ",(0,i.kt)("inlineCode",{parentName:"p"},"if"),". Only when ",(0,i.kt)("inlineCode",{parentName:"p"},"not")," or parentheses are used will behavior deviate from the standard."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="data"',title:'"data"'},'{\n  "user": {\n    "eligible": false,\n    "score": 5\n  },\n  "exempt": true\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-liquid",metastring:'title="template with parentheses"',title:'"template',with:!0,'parentheses"':!0},"{% if (user != empty and user.eligible and user.score > 100) or exempt %}\n    user is special\n{% else %}\n    denied\n{% endif %}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain",metastring:'title="output"',title:'"output"'},"user is special\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-liquid",metastring:'title="template without parentheses"',title:'"template',without:!0,'parentheses"':!0},"{% if user != empty and user.eligible and user.score > 100 or exempt %}\n    user is special\n{% else %}\n    denied\n{% endif %}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain",metastring:'title="output"',title:'"output"'},"denied\n")),(0,i.kt)("h2",{id:"inline-if--else"},"inline if / else"),(0,i.kt)("p",null,"Drop-in replacements for the standard output statement, ",(0,i.kt)("a",{parentName:"p",href:"/liquid/language/tags#assign"},(0,i.kt)("inlineCode",{parentName:"a"},"assign"))," tag, and ",(0,i.kt)("a",{parentName:"p",href:"/liquid/language/tags#echo"},(0,i.kt)("inlineCode",{parentName:"a"},"echo"))," tag that support inline ",(0,i.kt)("inlineCode",{parentName:"p"},"if"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"else")," expressions. You can find a BNF-like description of the inline conditional expression in ",(0,i.kt)("a",{parentName:"p",href:"https://gist.github.com/jg-rp/e2dc4da9e5033e087e46016008a9d91c#file-inline_if_expression-bnf"},"this gist"),"."),(0,i.kt)("p",null,"Inline ",(0,i.kt)("inlineCode",{parentName:"p"},"if"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"else")," expressions are designed to be backwards compatible with standard filtered expressions. As long as there are no template variables called ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," within a filtered expression, standard output statements, ",(0,i.kt)("inlineCode",{parentName:"p"},"assign")," tags and ",(0,i.kt)("inlineCode",{parentName:"p"},"echo")," tags will behave the same."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from liquid import Environment\nfrom liquid.extra import add_inline_expression_tags\n\nenv = Environment()\nadd_inline_expression_tags(env)\n\ntemplate = env.from_string("{{ \'hello user\' if user.logged_in else \'please log in\' }}")\n\ndata = {\n  "user": {\n    "logged_in": false\n  }\n}\n\nprint(template.render(**data))\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain",metastring:'title="output"',title:'"output"'},"please log in\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," part of an inline expression is optional, defaulting to ",(0,i.kt)("a",{parentName:"p",href:"/liquid/introduction/strictness#undefined-variables"},"undefined"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-liquid",metastring:'title="template"',title:'"template"'},"{{ 'hello user' if user.logged_in }}!\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain",metastring:'title="output"',title:'"output"'},"!\n")),(0,i.kt)("p",null,"Inline conditional expressions are evaluated lazily. If the condition is falsy, the leading object is not evaluated. Equally, if the condition is truthy, any expression following ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," will not be evaluated."),(0,i.kt)("h3",{id:"with-filters"},"With Filters"),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},'The inline conditional expressions added to Python Liquid 1.5.0 differs slightly from those found in Python Liquid Extra. Previously, trailing filters would be applied regardless of which branch of the condition was taken. Now, "tail filters" are distinguished from alternative branch filters with a double pipe token (',(0,i.kt)("inlineCode",{parentName:"p"},"||"),"). See examples below.")),(0,i.kt)("p",null,"Filters can appear before an inline ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," expression."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-liquid",metastring:'title="template"',title:'"template"'},"{{ 'hello user' | capitalize if user.logged_in else 'please log in' }}\n")),(0,i.kt)("p",null,"Or after an inline ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," expression. In which case filters will only be applied to the ",(0,i.kt)("inlineCode",{parentName:"p"},"else")," clause."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-liquid",metastring:'title="template"',title:'"template"'},"{% assign param = 'hello user' if user.logged_in else 'please log in' | url_encode %}\n")),(0,i.kt)("p",null,"Or both."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-liquid",metastring:'title="template"',title:'"template"'},"{{% assign param = 'hello user' | capitalize if user.logged_in else 'please log in' | url_encode %}\n")),(0,i.kt)("p",null,"Use a double pipe (",(0,i.kt)("inlineCode",{parentName:"p"},"||"),') to start any filters you want to apply regardless of which branch is taken. Subsequent "tail filters" should be separated by a single pipe (',(0,i.kt)("inlineCode",{parentName:"p"},"|"),")."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-liquid",metastring:'title="template"',title:'"template"'},"{{% assign name =\n  user.nickname | downcase\n  if user.has_nickname\n  else user.last_name | capitalize\n  || prepend: user.title | strip\n%}\n")),(0,i.kt)("h2",{id:"macro--call"},"macro / call"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain"},"{% macro <string> [[,] [ <object>, ... ] [ <identifier>: <object>, ... ]] %}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain"},"{% call <string> [[,] [ <object>, ... ] [ <identifier>: <object>, ... ]] %}\n")),(0,i.kt)("p",null,"Define parameterized Liquid snippets using the ",(0,i.kt)("inlineCode",{parentName:"p"},"macro")," tag, and call them using the ",(0,i.kt)("inlineCode",{parentName:"p"},"call")," tag."),(0,i.kt)("p",null,"Using the ",(0,i.kt)("inlineCode",{parentName:"p"},"macro")," tag is like defining a function. Its parameter list defines arguments, possibly with default values. A ",(0,i.kt)("inlineCode",{parentName:"p"},"macro")," tag's block has its own scope including its arguments and template global variables, just like the ",(0,i.kt)("inlineCode",{parentName:"p"},"render")," tag."),(0,i.kt)("p",null,"Note that argument defaults are bound late. They are evaluated when a ",(0,i.kt)("inlineCode",{parentName:"p"},"call")," expression is evaluated, not when the macro is defined."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from liquid import Environment\nfrom liquid import StrictUndefined\nfrom liquid.extra import add_macro_tags\n\nenv = Environment(undefined=StrictUndefined)\nadd_macro_tags(env)\n\ntemplate = env.from_string("""\\\n{% macro \'price\' product, on_sale: false %}\n  <div class="price-wrapper">\n  {% if on_sale %}\n    <p>Was {{ product.regular_price | prepend: \'$\' }}</p>\n    <p>Now {{ product.price | prepend: \'$\' }}</p>\n  {% else %}\n    <p>{{ product.price | prepend: \'$\' }}</p>\n  {% endif %}\n  </div>\n{% endmacro %}\n\n{% call \'price\' products[0], on_sale: true %}\n{% call \'price\' products[1] %}\n""")\n\ndata = {\n  "products": [\n    {\n      "title": "Some Shoes",\n      "regular_price": "5.99",\n      "price": "4.99"\n    },\n    {\n      "title": "A Hat",\n      "regular_price": "16.00",\n      "price": "12.00"\n    }\n  ]\n}\n\nprint(template.render(**data))\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="output"',title:'"output"'},'<div class="price-wrapper">\n  <p>Was $5.99</p>\n  <p>Now $4.99</p>\n</div>\n\n<div class="price-wrapper">\n  <p>$12.00</p>\n</div>\n')),(0,i.kt)("h3",{id:"excess-arguments"},"Excess Arguments"),(0,i.kt)("p",null,"Excess arguments passed to ",(0,i.kt)("inlineCode",{parentName:"p"},"call")," are collected into ",(0,i.kt)("inlineCode",{parentName:"p"},"args")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"kwargs"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-liquid",metastring:'title="template"',title:'"template"'},"{% macro 'foo' %}\n  {% for arg in args %}\n    - {{ arg }}\n  {% endfor %}\n\n  {% for arg in kwargs %}\n    - {{ arg.0 }} => {{ arg.1 }}\n  {% endfor %}\n{% endmacro %}\n\n{% call 'foo' 42, 43, 99, a: 3.14, b: 2.71828 %}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain",metastring:'title="output"',title:'"output"'},"- 42\n- 43\n- 99\n\n- a => 3.14\n- b => 2.71828\n")),(0,i.kt)("h2",{id:"with"},"with"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain"},"{% with <identifier>: <object> [, <identifier>: object ... ] %}\n  <literal,statement,tag> ...\n{% endwith %}\n")),(0,i.kt)("p",null,"Extend the local namespace with block scoped variables."),(0,i.kt)("p",null,"Register ",(0,i.kt)("inlineCode",{parentName:"p"},"WithTag")," with a ",(0,i.kt)("a",{parentName:"p",href:"/liquid/api/Environment"},(0,i.kt)("inlineCode",{parentName:"a"},"liquid.Environment"))," to make ",(0,i.kt)("inlineCode",{parentName:"p"},"with")," available to templates rendered from that environment."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from liquid import Environment\nfrom liquid.extra.tags import WithTag\n\nenv = Environment()\nenv.add_tag(WithTag)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json",metastring:'title="data"',title:'"data"'},'{ "collection": { "products": [{ "title": "A Shoe" }] } }\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-liquid",metastring:'title="template"',title:'"template"'},"{% with p: collection.products.first %}\n  {{ p.title }}\n{% endwith %}\n{{ p.title }}\n\n{% with a: 1, b: 3.4 %}\n  {{ a }} + {{ b }} = {{ a | plus: b }}\n{% endwith %}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-plain",metastring:'title="output"',title:'"output"'},"A Shoe\n\n1 + 3.4 = 4.4\n")))}u.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),o=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=o(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),m=o(n),c=i,g=m["".concat(s,".").concat(c)]||m[c]||u[c]||r;return n?a.createElement(g,l(l({ref:t},d),{},{components:n})):a.createElement(g,l({ref:t},d))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=m;var p={};for(var s in t)hasOwnProperty.call(t,s)&&(p[s]=t[s]);p.originalType=e,p.mdxType="string"==typeof e?e:i,l[1]=p;for(var o=2;o<r;o++)l[o]=n[o];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);